## Coins in a Line  ##

There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.

Could you please decide the first play will win or lose?

Example

	n = 1, return true.
	
	n = 2, return true.
	
	n = 3, return false.
	
	n = 4, return true.
	
	n = 5, return true.

Challenge 
O(n) time and O(1) memory

Tags 
Greedy Array Dynamic Programming Game Theory
Related Problems 
Hard Coins in a Line III 33 %
Medium Coins in a Line II 32 %

----------
Dynamic Programming
这是一类博弈类的DP问题．

博弈问题的基本解决思路是：

state:定义其中一个人的状态．

function:考虑两个人的状态做更新，即根据相互对抗的一个关系来做决策．

博弈类题目适合从大的状态往小的状态递推，非常适合记忆化搜索.不过这题本身比较简单，可以已经bottom-up来做.

这里分析f[i]为还剩ｉ枚硬币的时候先手能否获胜．我们考虑递推状态．先手在f[i]可以获胜，即他拿了最后一枚或者两枚硬币．这样在f[i-1]后者f[i-2]时是后手获胜的，所以有递推关系f[i] = !f[i-1]||!f[i-2]

初始化，还剩０枚硬币时先手肯定输．还剩１，２枚硬币时先手能赢．但是最后的结果取什么呢．是还剩０枚硬币，还是n枚．其实我们是从还有n枚硬币，考虑这时候的博弈状态考量的，所以是f[n].
Algorithm with O(1) Time, O(1) Space
其实此问题如果从另一个角度思考，就是从最后剩余1个或2个硬币时进行倒推，寻找规律：

先手输：

	o o o | o o o
先手胜：

	o | o o o
制胜的方法就是一定在倒数第二个回合时，让对手面对3个硬币，这样因为自己可以拿1或者2个硬币，那么无论对手选1个或者2个，己方都可以拿到最后一个硬币。这个规律就是每次让对手都面对3的倍数个硬币，那么无论对方取1个或者2个，只需要取相应的硬币数，让剩下的硬币数目保持3X，这样就能够保证取胜。对于先手而言，如果自己第一轮面对的就是3的倍数个硬币，那么对手则可以使用同样的策略让自己一方每次面对3X个硬币。于是先手是否获胜的唯一要素就是初始硬币数目，在不为3的整数倍情况下，先手都可以获胜。这样的话，算法时间复杂度和空间复杂度都为O(1)。

	 bool firstWillWin(int n) {
	    // write your code here
	    if (n % 3 == 0) {
	        return false;
	    }
	    return true;
	}

一、动态规划（记忆化搜索）

定义状态： f[i] 为现在还剩 i 个硬币，先手取硬币最终的输赢状况。
定义状态转移函数： 可参考以下图示，在还剩 i 个硬币的时候，先手有两种取法，取 1 个或者取 2 个硬币，在这两种情况，后手也分别有两种取法，取 1 个或者取 2 个，所以在轮到先手下一次取硬币时，一共有四种情况，只有当情况 a 和 b 一定能赢，或者 c 和 d 一定能赢时，先手才能获得胜利，对应状态转移为 f[i] = (f[i - 2] && f[i - 3]) || (f[i - 3]&&f[i - 4])。
定义起点：初始化状态转移函数无法涉及的状态 f[1] = true, f[2] = true, f[3] = false, f[4] = true 。
定义终点：为 f[n]。

![](http://ww2.sinaimg.cn/mw690/600e6311jw1f9cgghur63j20gi0aemy3.jpg)
// 方法一

	public class Solution {
	    /**
	     * @param n: an integer
	     * @return: a boolean which equals to true if the first player will win
	     */
	    public boolean firstWillWin(int n) {
	        // write your code here
	        int []dp = new int[n+1];
	
	        return MemorySearch(n, dp);
	
	    }
	    boolean MemorySearch(int n, int []dp) { // 0 is empty, 1 is false, 2 is true
	        if(dp[n] != 0) {
	            if(dp[n] == 1)
	                return false;
	            else
	                return true;
	        }
	        if(n <= 0) {
	            dp[n] = 1;
	        } else if(n == 1) {
	            dp[n] = 2;
	        } else if(n == 2) {
	            dp[n] = 2;
	        } else if(n == 3) {
	            dp[n] = 1;
	        } else {
	            if((MemorySearch(n-2, dp) && MemorySearch(n-3, dp)) || 
	                (MemorySearch(n-3, dp) && MemorySearch(n-4, dp) )) {
	                dp[n] = 2;
	            } else {
	                dp[n] = 1;
	            }
	        }
	        if(dp[n] == 2) 
	            return true;
	        return false;
	    }
	}
// 方法二

	public class Solution {
	    /**
	     * @param n: an integer
	     * @return: a boolean which equals to true if the first player will win
	     */
	    public boolean firstWillWin(int n) {
	        // write your code here
	        boolean []dp = new boolean[n+1];
	        boolean []flag = new boolean[n+1];
	        return MemorySearch(n, dp, flag);
	    }
	    boolean MemorySearch(int i, boolean []dp, boolean []flag) {
	        if(flag[i] == true) {
	            return dp[i];
	        }
	        if(i == 0) {
	            dp[i] = false;
	        } else if(i == 1) {
	            dp[i] = true;
	        } else if(i == 2) {
	            dp[i] = true;
	        } else {
	            dp[i] = !MemorySearch(i-1, dp, flag) || !MemorySearch(i-2, dp, flag);
	        }
	        flag[i] =true;
	        return dp[i];
	    }
	}
//方法三

	public class Solution {
	    /**
	     * @param n: an integer
	     * @return: a boolean which equals to true if the first player will win
	     */
	    public boolean firstWillWin(int n) {
	        // write your code here
	        if (n == 0)
	            return false;
	        else if (n == 1)
	            return true;
	        else if (n == 2)
	            return true;
	
	        boolean []dp = new boolean[n+1];
	        dp[0] = false;
	        dp[1] = true;
	        dp[2] = true;
	        for (int i = 3; i <= n; i++) 
	            dp[i] = !dp[i - 1] || !dp[i - 2];
	
	        return dp[n];
	    }
	}