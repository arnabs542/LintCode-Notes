## Minimum Path Sum  ##

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

 Notice

You can only move either down or right at any point in time.

Example

Tags 
Dynamic Programming

Related Problems 

- Easy Triangle 26 %
- Medium Binary Tree Maximum Path Sum 25 %

----------
	int minPathSum(vector<vector<int> > &grid) {
	    // write your code here
	    int m = grid.size();
	    if (m < 1) {
	        return 0;
	    }
	    int n = grid[0].size();
	    if (n < 1) {
	        return 0;
	    }
	    vector<vector<int>> dp(m, vector<int>(n));
	    dp[0][0] = grid[0][0];
	    for (int i = 1; i < m; i++) {
	        dp[i][0] = dp[i - 1][0] + grid[i][0];
	    }
	    for (int j = 1; j < n; j++) {
	        dp[0][j] = dp[0][j - 1] + grid[0][j];
	    }
	    for (int i = 1; i < m; i++) {
	        for (int j = 1; j < n; j++) {
	            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
	        }
	    }
	    return dp[m - 1][n - 1];
	}