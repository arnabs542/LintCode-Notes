## Word Squares  ##

Given a set of words without duplicates, find all word squares you can build from them.

A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).

For example, the word sequence ["ball","area","lead","lady"] forms a word square because each word reads the same both horizontally and vertically.

	b a l l
	a r e a
	l e a d
	l a d y
 Notice

There are at least 1 and at most 1000 words.
All words will have the exact same length.
Word length is at least 1 and at most 5.
Each word contains only lowercase English alphabet a-z.

Example
Given a set ["area","lead","wall","lady","ball"]
return [["wall","area","lead","lady"],["ball","area","lead","lady"]]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).

Given a set ["abat","baba","atan","atal"]
return [["baba","abat","baba","atan"],["baba","abat","baba","atal"]]
Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).

Tags 
Backtracking Trie Google

Related Problems 

- Hard Boggle Game 18 %
- Hard K Edit Distance 28 %
- Medium Implement Trie 32 %

----------


	class Solution {
	public:
	    struct TrieNode {
	        vector<int> indexs;
	        vector<TrieNode*> children;
	        TrieNode(): children(26, nullptr) {}
	    };
	    TrieNode* buildTrie(vector<string>& words) {
	        TrieNode *root = new TrieNode();
	        for (int i = 0; i < words.size(); ++i) {
	            TrieNode *t = root;
	            for (int j = 0; j < words[i].size(); ++j) {
	                if (!t->children[words[i][j] - 'a']) {
	                    t->children[words[i][j] - 'a'] = new TrieNode();
	                }
	                t = t->children[words[i][j] - 'a'];
	                t->indexs.push_back(i);
	            }
	        }
	        return root;
	    }
	    /*
	     * @param words: a set of words without duplicates
	     * @return: all word squares
	     */
	    vector<vector<string>> wordSquares(vector<string> &words) {
	        // write your code here
	        TrieNode *root = buildTrie(words);
	        vector<vector<string>> res;
	        if(words.size() == 0){
	            return res;
	        }
	        vector<string> out(words[0].size());
	        for (string word : words) {
	            out[0] = word;
	            helper(words, 1, root, out, res);
	        }
	        return res;
	    }
	    
	    void helper(vector<string>& words, int level, TrieNode* root, vector<string>& out, vector<vector<string>>& res) {
	        if (level >= words[0].size()) {
	            res.push_back(out);
	            return;
	        }
	        string str = "";
	        for (int i = 0; i < level; ++i) {
	            str += out[i][level];
	        }
	        TrieNode *t = root;
	        for (int i = 0; i < str.size(); ++i) {
	            if (!t->children[str[i] - 'a']) return;
	            t = t->children[str[i] - 'a'];
	        }
	        for (int idx : t->indexs) {
	            out[level] = words[idx];
	            helper(words, level + 1, root, out, res);
	        }
	    }
	};


// version: 高频题班

	class Solution {
	public:
	  /**
	   * @param words a set of words without duplicates
	   * @return all word squares
	   */
	  int wordLen;
	  unordered_map<string, vector<string> > prefix;
	  vector<string> squares;
	  vector<vector<string> > ans;
	  
	  void initPrefix(vector<string>& words) {
	    for (int i = 0; i < words.size(); i++) {
	      string item = words[i];
	      prefix[""].push_back(item);
	      for (int j = 0; j < item.length(); j++)
	        prefix[item.substr(0, j + 1)].push_back(item);
	    }
	  }
	  
	  bool checkPrefix(int l, string nextWord) {
	    for (int j = l + 1; j < wordLen; j++) {
	      string pre;
	      for (int k = 0; k < l; k++) { 
	        pre += squares[k][j];
	      } 
	      pre += nextWord[j];
	      if (prefix[pre].size() == 0) {
	        return false;
	      } 
	    }
	    return true;
	  }
	  
	  void dfs(int l) {
	    if (l == wordLen) {
	      ans.push_back(squares);
	      return;
	    }
	    string pre;
	    for (int i = 0; i < l; i++)
	      pre += squares[i][l];
	    vector<string> w = prefix[pre];
	    
	    for (int i = 0; i < w.size(); i++) {
	      if (!checkPrefix(l, w[i])) {
	        continue;
	      } 
	      squares.push_back(w[i]);
	      dfs(l + 1);
	      squares.pop_back();
	    }
	  }
	  
	  vector<vector<string>> wordSquares(vector<string>& words) {
	    // Write your code here
	    if (words.size() == 0) {
	      return ans;
	    }
	    initPrefix(words);
	    wordLen = words[0].length();
	    dfs(0);
	    return ans;
	  }
	};